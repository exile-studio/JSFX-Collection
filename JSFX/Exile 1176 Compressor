desc:Exile 1176 Compressor

// ------------------------------------------------------------
// Exile Studio – JSFX Collection
// Name   : Exile 1176 Compressor
// Version: 1.12
// Author : Michele Raggi
// Repo   : https://github.com/exile-studio/JSFX-Collection
//
// License: Creative Commons Attribution 4.0 International (CC BY 4.0)
//          You are free to use, modify, and redistribute this file,
//          including in commercial projects, as long as you provide
//          appropriate credit to "exile_studio" and indicate if changes
//          were made.
//
// Additional notes:
//   All references to existing brands, products, hardware models,
//   or company names are used purely for descriptive and comparative
//   purposes. They are not endorsements, not affiliations, and 
//   definitely not official models.
//   And yes - they’re written in clear text because, honestly,
//   who the fuck cares.
//
// Full license text:
//   https://creativecommons.org/licenses/by/4.0/
//
// Support / warranty:
//   None. Use at your own risk.
// ------------------------------------------------------------

//----------------------------------------------------
// Sliders
//----------------------------------------------------
slider1: 0 < -24, 24, 0.1 > Input(dB)
slider2: 0 < 0, 3, 1 > { 4: 1, 8: 1, 12: 1, 20: 1 } Ratio
slider3: 4 < 1, 7, 1 > Attack(1 = Slow, 7 = Fast)
slider4: 4 < 1, 7, 1 > Release(1 = Slow, 7 = Fast)
slider5: 0.4 < 0, 1, 0.01 > Color(0 = clean LN, 1 = dirty Rev A)
slider6: 0 < -24, 24, 0.1 > Output(dB)
slider7: 0 < -6, 6, 0.1 > -Legacy Trim(unused)
slider8: 0 < -40, 0, 0.1 > Gain Reduction(dB)

//----------------------------------------------------
// @init
//----------------------------------------------------
@init
tiny = 0.000000000000000001;

envL = 0; envR = 0;
env_fastL = 0; env_fastR = 0;
env_slowL = 0; env_slowR = 0;
fb_tap_prevL = 0; fb_tap_prevR = 0;

// ADAA safety epsilons (conservative to avoid divide-by-tiny spikes)
adaa_dx_min = 0.0000001;
adaa_num_min = 0.0000000001;
drive_change_eps = 0.0005;

// Audio path ADAA
x_prevL = 0; x_prevR = 0;
adaa_startedL = 0; adaa_startedR = 0;

// Detector path ADAA
x_prev_detL = 0; x_prev_detR = 0;
adaa_started_detL = 0; adaa_started_detR = 0;

fet_drive_prevL = 0; fet_drive_prevR = 0;

LOG10_TO_DB = 20 / log(10);

// For program-dependent release
GR_dB_L_prev = 0;
GR_dB_R_prev = 0;

// Blackface-ish tilt filter state
tilt_lf_L = 0; tilt_lf_R = 0;

// Attack/Release tables
function get_attack_ms(pos) (
  pos == 1 ? 0.80 :
    pos == 2 ? 0.40 :
      pos == 3 ? 0.22 :
        pos == 4 ? 0.12 :
          pos == 5 ? 0.065 :
            pos == 6 ? 0.035 :    // ~35 µs
              0.020;                // position 7 = 20 µs → nuclear fast, exactly like real Rev D/E
);

function get_release_ms(pos) (
  pos <= 1 ? 1100 :
    pos == 2 ? 800 :
      pos == 3 ? 600 :
        pos == 4 ? 400 :
          pos == 5 ? 250 :
            pos == 6 ? 150 : 50;
);

// Mild nonlinear control law to mimic 1176's less-linear FET behavior.
function fet_over_nl(over, eff_r) local(k, t, rnorm)(
  over <= 0 ? 0 : (
    rnorm = min(1, max(0, (eff_r - 4) / 16)); // 4:1 -> 0, 20:1 -> 1
k = 0.12 + 0.10 * rnorm;                  // stronger bend at higher ratios
t = 10;                                   // dB scale for curvature onset
over * (1 + k * (1 - exp(-over / t)));
  );
);

// tanh / cosh
function my_tanh(t) local(e2)(
  e2 = exp(2 * t);
(e2 - 1) / (e2 + 1);
);
function my_cosh(t) local(ex, enx)(
  ex = exp(t); enx = exp(-t);
(ex + enx) * 0.5;
);

function fet_f(x, d) local(t)(
  t = d * x;
my_tanh(t);
);
function fet_F(x, d) local(t, c)(
  t = d * x;
c = my_cosh(t);
c <= 0 ? 0 : log(c) / d;
);

//----------------------------------------------------
// @slider
//----------------------------------------------------
@slider
ingain = 10 ^ (slider1 / 20);
outgain = 10 ^ (slider6 / 20);

ratio_idx = slider2 | 0;
ratio = ratio_idx == 0 ? 4 :
  ratio_idx == 1 ? 8 :
    ratio_idx == 2 ? 12 : 20;

// --- effective ratios (hardware-ish) ---  // <<< CHANGED
eff_ratio =
  ratio == 4 ? 4.3 :
    ratio == 8 ? 8.8 :
      ratio == 12 ? 14 :
        20;

atk_pos = slider3 | 0;
rel_pos = slider4 | 0;
atk_ms = get_attack_ms(atk_pos);
rel_ms = get_release_ms(rel_pos);
atk_a = exp(-1 / (srate * (atk_ms / 1000)));
rel_fast_a = exp(-1 / (srate * (rel_ms / 1000)));
rel_slow_a = exp(-1 / (srate * ((rel_ms * 4.5) / 1000)));

// 1176-style behavior: fixed internal threshold, GR driven by Input and program level.
// slider7 kept only as hidden legacy slot for compatibility with old preset states.
thresh_base_dB = -12;
thresh_dB = thresh_base_dB;
thresh_lin = 10 ^ (thresh_dB / 20);

// MASTER COLOR KNOB
color = slider5;

// --- detector coloration ---                // <<< CHANGED
// Softer drive & sat so side-chain isn't smashed
detector_sat = 0.10 + color * 0.50;   // 0.10 → 0.60
base_det_drive = 1.0;
detector_drive = base_det_drive + color * 0.25; // 1.0 → 1.25

// Ratio-to-control slope for analog-style gain-cell law.
ratio_ctrl_k =
  ratio == 4 ? 0.50 :
    ratio == 8 ? 0.72 :
      ratio == 12 ? 0.90 : 1.15;

// Blackface-ish tilt for freq-dependent drive (pivot ~800 Hz)
tilt_fc = 800;
tilt_alpha = exp(-2 * $pi * tilt_fc / srate);

tilt_amt = 0.18 * color;
harm_mix = color;

// Feedback detector trim (calibrated): keeps usable threshold mapping with feedback tap.
fb_detect_boost = 2.0; // ~+6.0 dB

//----------------------------------------------------
// @sample
//----------------------------------------------------
@sample
xL = spl0 * ingain;
xR = spl1 * ingain;

// ===== DETECTOR WITH COLOR =====
// Feedback-style detector tap: previous post-gain sample (bootstrap only when tap is silent).
raw_detL = abs(fb_tap_prevL) * fb_detect_boost;
raw_detR = abs(fb_tap_prevR) * fb_detect_boost;
(raw_detL < tiny) ? raw_detL = abs(xL) * fb_detect_boost;
(raw_detR < tiny) ? raw_detR = abs(xR) * fb_detect_boost;


detector_sat > 0 ? (
  adaa_started_detL == 0 ? (
    det_satL = fet_f(raw_detL, detector_drive);
detL = raw_detL + detector_sat * (det_satL - raw_detL);
x_prev_detL = raw_detL;
adaa_started_detL = 1;
  ) : (
  dx = raw_detL - x_prev_detL;
det_satL = abs(dx) < adaa_dx_min ?
  fet_f((raw_detL + x_prev_detL) * 0.5, detector_drive) :
  (fet_F(raw_detL, detector_drive) - fet_F(x_prev_detL, detector_drive)) / dx;
detL = raw_detL + detector_sat * (det_satL - raw_detL);
x_prev_detL = raw_detL;
  );
) : detL = raw_detL;

detector_sat > 0 ? (
  adaa_started_detR == 0 ? (
    det_satR = fet_f(raw_detR, detector_drive);
detR = raw_detR + detector_sat * (det_satR - raw_detR);
x_prev_detR = raw_detR;
adaa_started_detR = 1;
  ) : (
  dx = raw_detR - x_prev_detR;
det_satR = abs(dx) < adaa_dx_min ?
  fet_f((raw_detR + x_prev_detR) * 0.5, detector_drive) :
  (fet_F(raw_detR, detector_drive) - fet_F(x_prev_detR, detector_drive)) / dx;
detR = raw_detR + detector_sat * (det_satR - raw_detR);
x_prev_detR = raw_detR;
  );
) : detR = raw_detR;

// ===== DUAL-STAGE ENVELOPE (analog-like attack/release) =====
slow_w_L = 0.20 + 0.55 * (1 - exp(-max(0, GR_dB_L_prev) / 8));
slow_w_R = 0.20 + 0.55 * (1 - exp(-max(0, GR_dB_R_prev) / 8));
slow_w_L = min(max(slow_w_L, 0), 0.85);
slow_w_R = min(max(slow_w_R, 0), 0.85);

(detL > env_fastL) ?
  env_fastL = atk_a * env_fastL + (1 - atk_a) * detL :
  env_fastL = rel_fast_a * env_fastL + (1 - rel_fast_a) * detL;

(detR > env_fastR) ?
  env_fastR = atk_a * env_fastR + (1 - atk_a) * detR :
  env_fastR = rel_fast_a * env_fastR + (1 - rel_fast_a) * detR;

(detL > env_slowL) ?
  env_slowL = atk_a * env_slowL + (1 - atk_a) * detL :
  env_slowL = rel_slow_a * env_slowL + (1 - rel_slow_a) * detL;

(detR > env_slowR) ?
  env_slowR = atk_a * env_slowR + (1 - atk_a) * detR :
  env_slowR = rel_slow_a * env_slowR + (1 - rel_slow_a) * detR;

envL = (1 - slow_w_L) * env_fastL + slow_w_L * env_slowL;
envR = (1 - slow_w_R) * env_fastR + slow_w_R * env_slowR;

(envL < tiny) ? envL = tiny;
(envR < tiny) ? envR = tiny;

// ===== GAIN COMPUTER (analog-style control-voltage law) =====
over_cv_L = max(envL - thresh_lin, 0);
over_cv_R = max(envR - thresh_lin, 0);

normL = over_cv_L / max(thresh_lin, tiny);
normR = over_cv_R / max(thresh_lin, tiny);
normL = min(normL, 40);
normR = min(normR, 40);

controlL = ratio_ctrl_k * log(1 + normL);
controlR = ratio_ctrl_k * log(1 + normR);

gL = exp(-controlL);
gR = exp(-controlR);

gL = min(max(gL, tiny), 1);
gR = min(max(gR, tiny), 1);

GR_dB_L = -LOG10_TO_DB * log(gL);
GR_dB_R = -LOG10_TO_DB * log(gR);



// ===== STORE GR FOR NEXT SAMPLE =====
GR_dB_L_prev = GR_dB_L;
GR_dB_R_prev = GR_dB_R;

// ===== FET AUDIO-PATH SATURATION =====
v_baseL = gL * xL;
v_baseR = gR * xR;

(color <= 0) ? (
  yL = v_baseL;
yR = v_baseR;
) : (

  // tilt only on sat branch
  tilt_lf_L = (1 - tilt_alpha) * v_baseL + tilt_alpha * tilt_lf_L;
tilt_hf_L = v_baseL - tilt_lf_L;

gain_l = 1 + tilt_amt;
gain_h = 1 - 0.6 * tilt_amt;

preL = tilt_lf_L * gain_l + tilt_hf_L * gain_h;

tilt_lf_R = (1 - tilt_alpha) * v_baseR + tilt_alpha * tilt_lf_R;
tilt_hf_R = v_baseR - tilt_lf_R;

preR = tilt_lf_R * gain_l + tilt_hf_R * gain_h;

// GR-dependent drive
drive_extra_L = color * 0.45 * (1 - exp(-max(0, GR_dB_L) / 10));
drive_extra_R = color * 0.45 * (1 - exp(-max(0, GR_dB_R) / 10));
drive_extra_L = min(drive_extra_L, 0.45);
drive_extra_R = min(drive_extra_R, 0.45);

fet_driveL = 1 + drive_extra_L;
fet_driveR = 1 + drive_extra_R;

(abs(fet_driveL - fet_drive_prevL) > drive_change_eps) ? (adaa_startedL = 0; x_prevL = 0);
(abs(fet_driveR - fet_drive_prevR) > drive_change_eps) ? (adaa_startedR = 0; x_prevR = 0);
fet_drive_prevL = fet_driveL;
fet_drive_prevR = fet_driveR;

// LEFT ADAA
adaa_startedL == 0 ? (
  satL = fet_f(preL, fet_driveL);
x_prevL = preL;
adaa_startedL = 1;
  ) : (
  dxL = preL - x_prevL;
(abs(preL) < tiny && abs(x_prevL) < tiny) ? satL = 0 : (
  FL = fet_F(preL, fet_driveL);
FpL = fet_F(x_prevL, fet_driveL);
numL = FL - FpL;
(abs(dxL) < adaa_dx_min || abs(numL) < adaa_num_min) ?
  satL = fet_f((preL + x_prevL) * 0.5, fet_driveL) :
  satL = numL / dxL;
    );
x_prevL = preL;
  );

yL = preL + harm_mix * (satL - preL);

// RIGHT ADAA
adaa_startedR == 0 ? (
  satR = fet_f(preR, fet_driveR);
x_prevR = preR;
adaa_startedR = 1;
  ) : (
  dxR = preR - x_prevR;
(abs(preR) < tiny && abs(x_prevR) < tiny) ? satR = 0 : (
  FR = fet_F(preR, fet_driveR);
FpR = fet_F(x_prevR, fet_driveR);
numR = FR - FpR;
(abs(dxR) < adaa_dx_min || abs(numR) < adaa_num_min) ?
  satR = fet_f((preR + x_prevR) * 0.5, fet_driveR) :
  satR = numR / dxR;
    );
x_prevR = preR;
  );

yR = preR + harm_mix * (satR - preR);
);

// Hard safety guards for rare numeric blowups.
(yL != yL || abs(yL) > 16) ? yL = 0;
(yR != yR || abs(yR) > 16) ? yR = 0;

// 1176-ish feedback tap: post gain-control nonlinearity (what the loop effectively "hears")
fb_tap_prevL = yL;
fb_tap_prevR = yR;

// ===== METER =====
GR_avg = (GR_dB_L + GR_dB_R) * 0.5;
slider8 = -max(0, GR_avg);
sliderchange(slider8);

// ===== OUTPUT =====
spl0 = yL * outgain;
spl1 = yR * outgain;


// ===================== @gfx (unchanged) =====================
@gfx 260 80

gfx_clear = 0;

// outer panel
gfx_r = gfx_g = gfx_b = 0.12; gfx_a = 1;
gfx_rect(0, 0, gfx_w, gfx_h);

// inner panel
margin = 8;
panel_x = margin;
panel_y = 20;
panel_w = gfx_w - 2 * margin;
panel_h = gfx_h - panel_y - margin;

gfx_r = gfx_g = gfx_b = 0.06; gfx_a = 1;
gfx_rect(panel_x, panel_y, panel_w, panel_h);

// border
gfx_r = gfx_g = gfx_b = 0.35; gfx_a = 1;
gfx_rect(panel_x, panel_y, panel_w, panel_h, 0);

// label
gfx_r = gfx_g = gfx_b = 0.9; gfx_a = 1;
gfx_x = panel_x;
gfx_y = 4;
gfx_printf("GAIN REDUCTION");

// meter geometry
meter_x = panel_x + 6;
meter_y = panel_y + 6;
meter_w = panel_w - 12;
meter_h = panel_h - 12;

// outline
gfx_r = gfx_g = gfx_b = 0.4; gfx_a = 1;
gfx_rect(meter_x, meter_y, meter_w, meter_h, 0);

// GR value (0..30 dB)
gr = -slider8;
gr < 0 ? gr = 0;
gr > 30 ? gr = 30;

norm = meter_w > 0 ? (gr / 30) : 0;
fill_w = meter_w * norm;

// background
gfx_r = 0.05; gfx_g = 0.15; gfx_b = 0.05; gfx_a = 1;
gfx_rect(meter_x + 1, meter_y + 1, meter_w - 2, meter_h - 2);

// tick marks
gfx_r = gfx_g = gfx_b = 0.6; gfx_a = 1;
tick_h = meter_h * 0.4;

i = 0;
loop(7,
  t = i / 6;
tx = meter_x + meter_w - t * meter_w;
ty0 = meter_y + (meter_h - tick_h) * 0.5;
ty1 = ty0 + tick_h;
gfx_line(tx, ty0, tx, ty1);
i += 1;
);

// filled bar (right → left)
fill_w > 1 ? (
  gfx_r = 0.15; gfx_g = 0.85; gfx_b = 0.25; gfx_a = 1;
gfx_rect(meter_x + meter_w - 1 - fill_w,
  meter_y + 2,
  fill_w,
  meter_h - 4);
);

// numeric readout
gfx_r = gfx_g = gfx_b = 0.75; gfx_a = 1;
gfx_x = meter_x;
gfx_y = meter_y + meter_h + 2;
gfx_printf("%4.1f dB", gr);
