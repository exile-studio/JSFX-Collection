desc:Exile SSL Bus Compressor

// ------------------------------------------------------------
// Exile Studio – JSFX Collection
// Name   : Exile SSL Bus Compressor
// Version: 1.0
// Author : Michele Raggi
// Repo   : https://github.com/exile-studio/JSFX-Collection
//
// License: Creative Commons Attribution 4.0 International (CC BY 4.0)
//          You are free to use, modify, and redistribute this file,
//          including in commercial projects, as long as you provide
//          appropriate credit to "exile_studio" and indicate if changes
//          were made.
//
// Additional notes:
//   All references to existing brands, products, hardware models,
//   or company names are used purely for descriptive and comparative
//   purposes. They are not endorsements, not affiliations, and 
//   definitely not official models.
//   And yes - they’re written in clear text because, honestly,
//   who the fuck cares.
//
// Full license text:
//   https://creativecommons.org/licenses/by/4.0/
//
// Support / warranty:
//   None. Use at your own risk.
// ------------------------------------------------------------

//----------------------------------------------------
// Sliders
//----------------------------------------------------
slider1: 0 < -24, 24, 0.1 > Input(dB)
slider2: -10 < -40, 0, 0.1 > Threshold(dB)
slider3: 1 < 0, 2, 1{ 2: 1, 4: 1, 10: 1 }> Ratio
slider4: 2 < 0, 5, 1{ 0.1 ms, 0.3 ms, 1 ms, 3 ms, 10 ms, 30 ms }> Attack
slider5: 2 < 0, 4, 1{ 0.1 s, 0.3 s, 0.6 s, 1.2 s, Auto }> Release
slider6: 0 < -24, 24, 0.1 > Makeup(dB)
slider7: 1 < 0, 1, 0.01 > Mix(0 = dry, 1 = wet)
slider8: 1 < 0, 4, 1{SC HPF Off, 60 Hz, 90 Hz, 150 Hz, 300 Hz }> Sidechain HPF
slider9: 0 < -24, 0, 0.1 > Gain Reduction(dB) // meter, read-only
slider10: 1 < 0, 1, 1{ Clean, Saturated }> Saturation

//----------------------------------------------------
// @init
//----------------------------------------------------
@init
tiny = 0.00000000000000000001;
LOG10_TO_DB = 20 / log(10);   // 20*log10(x)

// Linked detector state
env = 0;
level_prev = 0;

// SC HPF state
sc_hp_alpha = 0;
sc_hp_y = 0;
sc_hp_x_prev = 0;

// GR smoothing
GR_dB_smooth = 0;

// Auto-release bounds for GR domain
rel_ms_fast_GR = 50.0;     // 0.05 s fast component (GR domain)
rel_ms_slow_GR = 5000.0;   // 5.0 s slow tail (GR domain)
rel_a_fast_GR = 0;
rel_a_slow_GR = 0;

// ADAA parameters for audio-path saturation
adaa_dx_min = 0.000000000000001;
adaa_num_min = 0.000000000000000001;

adaa_prevL = 0;
adaa_prevR = 0;
adaa_startedL = 0;
adaa_startedR = 0;

//----------------------------------------------------
// Helpers
//----------------------------------------------------
function get_attack_ms(pos) (
  pos == 0 ? 0.1 :
    pos == 1 ? 0.3 :
      pos == 2 ? 1.0 :
        pos == 3 ? 3.0 :
          pos == 4 ? 10.0 : 30.0;
);

function get_release_ms(pos) (
  pos == 0 ? 100.0 :
    pos == 1 ? 300.0 :
      pos == 2 ? 600.0 : 1200.0;
);

// tanh / cosh helpers for ADAA saturator
function sat_tanh(t) local(e2)(
  e2 = exp(2 * t);
(e2 - 1) / (e2 + 1);
);

function sat_cosh(t) local(ex, enx)(
  ex = exp(t);
enx = exp(-t);
(ex + enx) * 0.5;
);

// base saturator curve: gentle VCA-ish tanh
function sat_f(x, drive) local(t)(
  t = drive * x;
sat_tanh(t);
);

// integral of saturator curve
function sat_F(x, drive) local(t, c)(
  t = drive * x;
c = sat_cosh(t);
c <= 0 ? 0 : log(c) / drive;     // integral of tanh(d x) dx
);

//----------------------------------------------------
// @slider
//----------------------------------------------------
@slider

ingain = 10 ^ (slider1 / 20);
makeup = 10 ^ (slider6 / 20);

thresh_dB = slider2;

// ratio
ratio_idx = slider3 | 0;
ratio = ratio_idx == 0 ? 2 :
  ratio_idx == 1 ? 4 : 10;

// attack coeff
atk_ms = get_attack_ms(slider4 | 0);
atk_a = exp(-1 / (srate * (atk_ms / 1000)));

// release mode (0..4, 4 = Auto)
rel_mode = slider5 | 0;

// detector release (env) – for Auto, anchor to 0.1 s base
rel_ms_fixed = rel_mode == 4 ? 100.0 : get_release_ms(rel_mode);
rel_a_fixed = exp(-1 / (srate * (rel_ms_fixed / 1000)));

// auto release bounds (GR-domain dual rate)
rel_a_fast_GR = exp(-1 / (srate * (rel_ms_fast_GR / 1000)));
rel_a_slow_GR = exp(-1 / (srate * (rel_ms_slow_GR / 1000)));

// SC HPF freq
sc_hp_fc =
  slider8 == 0 ? 0 :
    slider8 == 1 ? 60 :
      slider8 == 2 ? 90 :
        slider8 == 3 ? 150 : 300;

sc_hp_alpha = 0;
sc_hp_fc > 0 ? (
  w = 2 * $pi * sc_hp_fc / srate;
sc_hp_alpha = exp(-w);
);

// mix
mix = slider7;

// saturation mode
sat_mode = slider10 | 0;
// slightly gentler drive than v6
sat_drive = 1.20;
// small loudness trim to match Clean vs Saturated
sat_makeup_db = -0.7;
sat_makeup = 10 ^ (sat_makeup_db / 20);

//----------------------------------------------------
// @sample
//----------------------------------------------------
@sample

// 1) Input + trim
inL = spl0 * ingain;
inR = spl1 * ingain;

// 2) Linked mono sidechain
sc = 0.5 * (inL + inR);

// Optional SC HPF (1-pole)
sc_hp_fc > 0 ? (
  tmp = sc_hp_y + sc - sc_hp_x_prev;
sc_hp_y = sc_hp_alpha * tmp;
sc_hp_x_prev = sc;
sc = sc_hp_y;
);

// 3) RMS-ish detector with slight ballistics bias
level_raw = abs(sc);
level = 0.75 * level_raw + 0.25 * level_prev;
level_prev = level_raw;

level < tiny ? level = tiny;

// Attack / release smoothing on amplitude (detector env)
(level > env) ?
  (
    // attack
    env = atk_a * env + (1 - atk_a) * level;
)
:
(
  // release (always uses musical fixed release, Auto handled in GR domain)
  env = rel_a_fixed * env + (1 - rel_a_fixed) * level;
);

// 4) Detector dB
env_dB = LOG10_TO_DB * log(env + tiny);

// 5) Gain computer with SOFT KNEE
// over-threshold in dB
over = env_dB - thresh_dB;

// soft knee (~3 dB)
knee_width = 3.0;
knee_half = knee_width * 0.5;

// GR_dB_target = positive dB of reduction
over <= -knee_half ? (
  GR_dB_target = 0;
) :
over >= knee_half ? (
  GR_dB_target = over * (1 - 1 / ratio);
) : (
  t = (over + knee_half) / knee_width;   // 0..1
full_GR = over * (1 - 1 / ratio);
GR_dB_target = full_GR * t * t;
);

// 6) Smooth GR in dB (attack/release in GR domain)
GR_dB_target > GR_dB_smooth ? (
  // more GR (increasing positive GR) → fast-ish attack
  GR_dB_smooth += (GR_dB_target - GR_dB_smooth) * 0.6;
) :
(
  // less GR (towards 0) → release
  rel_mode == 4 ? (
    // AUTO: dual-rate GR release based on current GR amount
    gr_mag = GR_dB_smooth;         // positive dB of current GR
gr_mag < 0 ? gr_mag = 0;
gr_mag > 6 ? gr_mag = 6;       // focus on 0..6 dB range

t_rel = gr_mag / 6;            // 0..1 (more GR → closer to fast)
rel_a_dyn = rel_a_slow_GR * (1 - t_rel) + rel_a_fast_GR * t_rel;

GR_dB_smooth = rel_a_dyn * GR_dB_smooth
  + (1 - rel_a_dyn) * GR_dB_target;
  ) :
(
  // fixed release
  GR_dB_smooth = rel_a_fixed * GR_dB_smooth
  + (1 - rel_a_fixed) * GR_dB_target;
  );
);

// clamp just in case
GR_dB_smooth < 0 ? GR_dB_smooth = 0;

// linear gain (APPLY REDUCTION)
gain = 10 ^ (-GR_dB_smooth / 20);

// expose GR meter as NEGATIVE (so slider goes 0 to -24)
slider9 = -GR_dB_smooth;
sliderchange(slider9);

// 7) Apply gain + makeup, then optional ADAA saturation
dryL = inL * gain * makeup;
dryR = inR * gain * makeup;

sat_mode == 0 ? (
  // Clean
  wetL = dryL;
wetR = dryR;
) :
(
  // LEFT ADAA
  adaa_startedL == 0 ? (
    satL = sat_f(dryL, sat_drive);
adaa_prevL = dryL;
adaa_startedL = 1;
  ) :
(
  dxL = dryL - adaa_prevL;

(abs(dryL) < tiny && abs(adaa_prevL) < tiny) ? (
  satL = 0;
    ) :
(
  FL = sat_F(dryL, sat_drive);
FpL = sat_F(adaa_prevL, sat_drive);
numL = FL - FpL;

(abs(dxL) < adaa_dx_min || abs(numL) < adaa_num_min) ?
  satL = sat_f(0.5 * (dryL + adaa_prevL), sat_drive) :
  satL = numL / dxL;
    );

adaa_prevL = dryL;
  );

// RIGHT ADAA
adaa_startedR == 0 ? (
  satR = sat_f(dryR, sat_drive);
adaa_prevR = dryR;
adaa_startedR = 1;
  ) :
(
  dxR = dryR - adaa_prevR;

(abs(dryR) < tiny && abs(adaa_prevR) < tiny) ? (
  satR = 0;
    ) :
(
  FR = sat_F(dryR, sat_drive);
FpR = sat_F(adaa_prevR, sat_drive);
numR = FR - FpR;

(abs(dxR) < adaa_dx_min || abs(numR) < adaa_num_min) ?
  satR = sat_f(0.5 * (dryR + adaa_prevR), sat_drive) :
  satR = numR / dxR;
    );

adaa_prevR = dryR;
  );

// apply subtle output trim for level match
wetL = satL * sat_makeup;
wetR = satR * sat_makeup;
);

// 8) Parallel
outL = mix * wetL + (1 - mix) * inL;
outR = mix * wetR + (1 - mix) * inR;

// 9) Output
spl0 = outL;
spl1 = outR;

